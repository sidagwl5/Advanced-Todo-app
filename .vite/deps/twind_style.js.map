{
  "version": 3,
  "sources": ["../../node_modules/src/css/index.ts", "../../node_modules/src/internal/util.ts", "../../node_modules/src/style/index.ts", "../../node_modules/src/internal/util.ts"],
  "sourcesContent": ["/**\n * [[include:src/css/README.md]]\n *\n * @packageDocumentation\n * @module twind/css\n */\n\nimport type {\n  CSSRules,\n  CSSAtKeyframes,\n  Context,\n  CSSProperties,\n  Directive,\n  Falsy,\n  MaybeThunk,\n  MaybeArray,\n  ThemeScreenValue,\n} from 'twind'\n\nimport { apply, hash, directive } from 'twind'\nimport { evalThunk, merge, buildMediaQuery } from '../internal/util'\n\nexport * from 'twind'\n\nexport interface CSSFactory<T, I, R> {\n  (\n    strings: TemplateStringsArray,\n    ...interpolations: readonly MaybeThunk<MaybeArray<I | string | number | Falsy>>[]\n  ): Directive<R>\n  (tokens: MaybeThunk<MaybeArray<T | Falsy>>): Directive<R>\n  (...tokens: readonly MaybeThunk<T | Falsy>[]): Directive<R>\n}\n\nconst translate = (tokens: unknown[], context: Context): CSSRules => {\n  const collect = (target: CSSRules, token: MaybeThunk<CSSRules>): CSSRules =>\n    Array.isArray(token)\n      ? token.reduce(collect, target)\n      : merge(target as CSSRules, evalThunk(token, context), context)\n\n  return (tokens as MaybeThunk<CSSRules>[]).reduce(collect, {} as CSSRules)\n}\n\n// Based on https://github.com/cristianbote/goober/blob/master/src/core/astish.js\nconst newRule = /\\s*(?:([\\w-%@]+)\\s*:?\\s*([^{;]+?)\\s*(?:;|$|})|([^;}{]*?)\\s*{)|(})/gi\nconst ruleClean = /\\/\\*[\\s\\S]*?\\*\\/|\\s+|\\n/gm\n\nconst decorate = (selectors: string[], currentBlock: CSSRules): CSSRules =>\n  selectors.reduceRight((rules, selector) => ({ [selector]: rules }), currentBlock)\n\nconst saveBlock = (\n  rules: CSSRules[],\n  selectors: string[],\n  currentBlock: CSSRules | undefined | void,\n): void => {\n  if (currentBlock) {\n    rules.push(decorate(selectors, currentBlock))\n  }\n}\n\nconst interleave = (\n  strings: TemplateStringsArray,\n  interpolations: unknown[],\n  context: Context,\n): unknown[] => {\n  let buffer = strings[0]\n  const result: unknown[] = []\n\n  for (let index = 0; index < interpolations.length; ) {\n    const interpolation = evalThunk(interpolations[index], context)\n\n    if (interpolation && typeof interpolation == 'object') {\n      result.push(buffer, interpolation)\n      buffer = strings[++index]\n    } else {\n      // Join consecutive strings\n      buffer += ((interpolation || '') as string) + strings[++index]\n    }\n  }\n\n  result.push(buffer)\n\n  return result\n}\n\nconst astish = (values: unknown[], context: Context): CSSRules[] => {\n  // Keep track of active selectors => these are the nested keys\n  const selectors: string[] = []\n  const rules: CSSRules[] = []\n\n  let currentBlock: CSSRules | undefined | void\n  let match: RegExpExecArray | null\n\n  for (let index = 0; index < values.length; index++) {\n    const value = values[index]\n\n    if (typeof value == 'string') {\n      while ((match = newRule.exec(value.replace(ruleClean, ' ')))) {\n        if (!match[0]) continue\n\n        // `}` => Save current block\n        if (match[4]) {\n          currentBlock = saveBlock(rules, selectors, currentBlock)\n          selectors.pop()\n        }\n\n        // `... {` => Start a new block\n        if (match[3]) {\n          // selector {\n          currentBlock = saveBlock(rules, selectors, currentBlock)\n          selectors.push(match[3])\n        } else if (!match[4]) {\n          if (!currentBlock) currentBlock = {}\n\n          const value = match[2] && /\\S/.test(match[2]) ? match[2] : (values[++index] as CSSRules)\n\n          if (value) {\n            if (match[1] == '@apply') {\n              merge(currentBlock, evalThunk(apply(value as string), context), context)\n            } else {\n              // a) property: value\n              currentBlock[match[1]] = value as CSSRules\n            }\n          }\n        }\n      }\n    } else {\n      currentBlock = saveBlock(rules, selectors, currentBlock)\n\n      rules.push(decorate(selectors, value as CSSRules))\n    }\n  }\n\n  saveBlock(rules, selectors, currentBlock)\n\n  return rules\n}\n\nconst cssFactory = (tokens: unknown[], context: Context): CSSRules =>\n  translate(\n    Array.isArray(tokens[0] as TemplateStringsArray) &&\n      Array.isArray((tokens[0] as TemplateStringsArray).raw)\n      ? astish(interleave(tokens[0] as TemplateStringsArray, tokens.slice(1), context), context)\n      : tokens,\n    context,\n  )\n\nexport const css: CSSFactory<CSSRules, CSSRules, CSSRules> = (\n  ...tokens: unknown[]\n): Directive<CSSRules> => directive(cssFactory, tokens)\n\nconst keyframesFactory = (tokens: unknown[], context: Context): string => {\n  const waypoints = cssFactory(tokens as CSSRules[], context)\n\n  const id = hash(JSON.stringify(waypoints))\n\n  // Inject the keyframes\n  context.tw(() => ({ [`@keyframes ${id}`]: waypoints }))\n\n  // but return the keyframe id\n  return id\n}\n\n/**\n *\n * ```js\n * const bounce = keyframes({\n *   'from, 20%, 53%, 80%, to': {\n *     transform: 'translate3d(0,0,0)',\n *   },\n *   '40%, 43%': {\n *     transform: 'translate3d(0, -30px, 0)',\n *   },\n *   '70%': {\n *     transform: 'translate3d(0, -15px, 0)',\n *   },\n *   '90%': {\n *     transform: 'translate3d(0, -4px, 0)',\n *   }\n * })\n *\n * css({\n *   animation: `${bounce} 1s ease infinite`,\n * })\n * ```\n * @param waypoints\n */\nexport const keyframes: CSSFactory<CSSAtKeyframes, CSSAtKeyframes | CSSProperties, string> = (\n  ...tokens: unknown[]\n): Directive<string> => directive(keyframesFactory, tokens)\n\n/**\n *\n * ```js\n * const bounce = animation('1s ease infinite', {\n *   'from, 20%, 53%, 80%, to': {\n *     transform: 'translate3d(0,0,0)',\n *   },\n *   '40%, 43%': {\n *     transform: 'translate3d(0, -30px, 0)',\n *   },\n *   '70%': {\n *     transform: 'translate3d(0, -15px, 0)',\n *   },\n *   '90%': {\n *     transform: 'translate3d(0, -4px, 0)',\n *   }\n * })\n * ```\n */\nexport interface Animation {\n  (value: string | CSSRules | ((context: Context) => string)): CSSFactory<\n    CSSAtKeyframes,\n    CSSAtKeyframes | CSSProperties,\n    CSSRules\n  >\n\n  (\n    value: string | CSSRules | ((context: Context) => string),\n    waypoints: CSSAtKeyframes | Directive<string>,\n  ): Directive<CSSRules>\n}\n\nexport const animation = ((\n  value: string | CSSRules | ((context: Context) => string),\n  waypoints?: CSSAtKeyframes | Directive<string>,\n): Directive<CSSRules> | CSSFactory<CSSAtKeyframes, CSSAtKeyframes | CSSProperties, CSSRules> =>\n  waypoints === undefined\n    ? (((...args: Parameters<typeof keyframes>): Directive<CSSRules> =>\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        animation(value, keyframes(...(args as any)))) as CSSFactory<\n        CSSAtKeyframes,\n        CSSAtKeyframes | CSSProperties,\n        CSSRules\n      >)\n    : css({\n        ...(value && typeof value == 'object' ? value : { animation: value }),\n        animationName: typeof waypoints == 'function' ? waypoints : keyframes(waypoints),\n      })) as Animation\n\nexport interface Screen {\n  (size: string): Directive<string>\n  (size: string, css: Directive<CSSRules> | MaybeArray<CSSRules | Falsy>): Directive<CSSRules>\n}\n\nconst screenFactory = (\n  { size, rules }: { size: string; rules?: Directive<CSSRules> | MaybeArray<CSSRules | Falsy> },\n  context: Context,\n): string | CSSRules => {\n  const media = buildMediaQuery(context.theme('screens', size) as ThemeScreenValue)\n\n  return rules === undefined\n    ? media\n    : {\n        [media]:\n          typeof rules == 'function' ? evalThunk(rules, context) : cssFactory([rules], context),\n      }\n}\n\nexport const screen = ((size: string, rules?: Directive<CSSRules> | MaybeArray<CSSRules | Falsy>) =>\n  directive(screenFactory, { size, rules })) as Screen\n", "import type {\n  Context,\n  Hasher,\n  Falsy,\n  MaybeThunk,\n  CSSRules,\n  ThemeScreen,\n  ThemeScreenValue,\n  CSSRuleValue,\n} from '../types'\n\ninterface Includes {\n  (value: string, search: string): boolean\n  <T>(value: readonly T[], search: T): boolean\n}\n\nexport const includes: Includes = (value: string | readonly unknown[], search: unknown) =>\n  // eslint-disable-next-line no-implicit-coercion\n  !!~(value as string).indexOf(search as string)\n\nexport const join = (parts: readonly string[], separator = '-'): string => parts.join(separator)\n\nexport const joinTruthy = (parts: readonly (string | Falsy)[], separator?: string): string =>\n  join(parts.filter(Boolean) as string[], separator)\n\nexport const tail = <T extends string | readonly unknown[]>(array: T, startIndex = 1): T =>\n  array.slice(startIndex) as T\n\nexport const identity = <T>(value: T): T => value\n\nexport const noop = (): void => {\n  /* no-op */\n}\n\nexport const capitalize = <T extends string>(value: T): Capitalize<T> =>\n  (value[0].toUpperCase() + tail(value)) as Capitalize<T>\n\nexport const hyphenate = (value: string): string => value.replace(/[A-Z]/g, '-$&').toLowerCase()\n\nexport const evalThunk = <T>(value: MaybeThunk<T>, context: Context): T => {\n  while (typeof value == 'function') {\n    value = (value as (context: Context) => T)(context)\n  }\n\n  return value\n}\n\nexport const ensureMaxSize = <K, V>(map: Map<K, V>, max: number): void => {\n  // Ensure the cache does not grow unlimited\n  if (map.size > max) {\n    map.delete(map.keys().next().value)\n  }\n}\n\n// string, number or Array => a property with a value\nexport const isCSSProperty = (key: string, value: CSSRuleValue): boolean =>\n  !includes('@:&', key[0]) && (includes('rg', (typeof value)[5]) || Array.isArray(value))\n\nexport const merge = (target: CSSRules, source: CSSRules, context: Context): CSSRules =>\n  source\n    ? Object.keys(source).reduce((target, key) => {\n        const value = evalThunk(source[key], context)\n\n        if (isCSSProperty(key, value)) {\n          // hyphenate target key only if key is property like (\\w-)\n          target[hyphenate(key)] = value\n        } else {\n          // Keep all @font-face, @import, @global, @apply as is\n          target[key] =\n            key[0] == '@' && includes('figa', key[1])\n              ? ((target[key] || []) as CSSRules[]).concat(value as CSSRules)\n              : merge((target[key] || {}) as CSSRules, value as CSSRules, context)\n        }\n\n        return target\n      }, target)\n    : target\n\nexport const escape =\n  (typeof CSS !== 'undefined' && CSS.escape) ||\n  // Simplified: escaping only special characters\n  // Needed for NodeJS and Edge <79 (https://caniuse.com/mdn-api_css_escape)\n  ((className: string): string =>\n    className\n      // Simplifed escape testing only for chars that we know happen to be in tailwind directives\n      .replace(/[!\"'`*+.,;:\\\\/<=>?@#$%&^|~()[\\]{}]/g, '\\\\$&')\n      // If the character is the first character and is in the range [0-9] (2xl, ...)\n      // https://drafts.csswg.org/cssom/#escape-a-character-as-code-point\n      .replace(/^\\d/, '\\\\3$& '))\n\nexport const buildMediaQuery = (screen: ThemeScreen): string => {\n  if (!Array.isArray(screen)) {\n    screen = [screen as ThemeScreenValue]\n  }\n\n  return (\n    '@media ' +\n    join(\n      (screen as ThemeScreenValue[]).map((screen) => {\n        if (typeof screen == 'string') {\n          screen = { min: screen }\n        }\n\n        return (\n          (screen as { raw?: string }).raw ||\n          join(\n            Object.keys(screen).map(\n              (feature) => `(${feature}-width:${(screen as Record<string, string>)[feature]})`,\n            ),\n            ' and ',\n          )\n        )\n      }),\n      ',',\n    )\n  )\n}\n\n// Based on https://stackoverflow.com/a/52171480\nexport const cyrb32: Hasher = (value: string): string => {\n  // eslint-disable-next-line no-var\n  for (var h = 9, index = value.length; index--; ) {\n    h = Math.imul(h ^ value.charCodeAt(index), 0x5f356495)\n  }\n\n  return 'tw-' + ((h ^ (h >>> 9)) >>> 0).toString(36)\n}\n\n/**\n * Find the array index of where to add an element to keep it sorted.\n *\n * @returns The insertion index\n */\nexport const sortedInsertionIndex = (array: readonly number[], element: number): number => {\n  // Find position by binary search\n  // eslint-disable-next-line no-var\n  for (var low = 0, high = array.length; low < high; ) {\n    const pivot = (high + low) >> 1\n\n    // Less-Then-Equal to add new equal element after all existing equal elements (stable sort)\n    if (array[pivot] <= element) {\n      low = pivot + 1\n    } else {\n      high = pivot\n    }\n  }\n\n  return high\n}\n", "/**\n * [[include:src/style/README.md]]\n *\n * @packageDocumentation\n * @module twind/style\n */\n\n// Based on https://github.com/modulz/stitches\n// License MIT\n\nimport type { Context, CSSRules, Directive, Token } from 'twind'\n\nimport { apply, directive, hash } from 'twind'\nimport { evalThunk, merge } from '../internal/util'\n\nexport * from 'twind/css'\n\nexport type StrictMorphVariant<T> = T extends number\n  ? `${T}` | T\n  : T extends 'true'\n  ? true | T\n  : T extends 'false'\n  ? false | T\n  : T\n\nexport type MorphVariant<T> = T extends number\n  ? `${T}` | T\n  : T extends 'true'\n  ? boolean | T\n  : T extends 'false'\n  ? boolean | T\n  : T extends `${number}`\n  ? number | T\n  : T\n\nexport type StyleToken = string | CSSRules | Directive<CSSRules>\n\nexport type VariantsOf<T> = T extends Style<infer Variants>\n  ? {\n      [key in keyof Variants]: MorphVariant<keyof Variants[key]>\n    }\n  : never\n\nexport type DefaultVariants<Variants> = {\n  [key in keyof Variants]?:\n    | StrictMorphVariant<keyof Variants[key]>\n    | (Record<string, StrictMorphVariant<keyof Variants[key]>> & {\n        initial?: StrictMorphVariant<keyof Variants[key]>\n      })\n}\n\nexport type VariantsProps<Variants> = {\n  [key in keyof Variants]?:\n    | MorphVariant<keyof Variants[key]>\n    | (Record<string, MorphVariant<keyof Variants[key]>> & {\n        initial?: MorphVariant<keyof Variants[key]>\n      })\n}\n\nexport type VariantMatchers<Variants> = {\n  [key in keyof Variants]?: StrictMorphVariant<keyof Variants[key]>\n}\n\n// eslint-disable-next-line @typescript-eslint/ban-types\nexport interface StyleConfig<Variants, BaseVariants = {}> {\n  base?: StyleToken\n  variants?: Variants &\n    { [variant in keyof BaseVariants]?: { [key in keyof BaseVariants[variant]]?: StyleToken } }\n  defaults?: DefaultVariants<Variants & BaseVariants>\n  matches?: (VariantMatchers<Variants & BaseVariants> & {\n    use: StyleToken\n  })[]\n}\n\nexport interface StyleFunction {\n  <Variants>(config?: StyleConfig<Variants>): Style<Variants> & string\n  <Variants, BaseVariants>(\n    base: Style<BaseVariants>,\n    config?: StyleConfig<Variants, BaseVariants>,\n  ): Style<BaseVariants & Variants> & string\n}\n\nexport interface BaseStyleProps {\n  tw?: Token\n  css?: CSSRules\n  class?: string\n  className?: string\n}\n\nexport type StyleProps<Variants> = VariantsProps<Variants> & BaseStyleProps\n\nexport interface Style<Variants> {\n  /**\n   * CSS Class associated with the current component.\n   *\n   * ```jsx\n   * const button = style({\n   *   base: {\n   *     color: \"DarkSlateGray\"\n   *   }\n   * })\n   *\n   * <div className={tw(button())} />\n   * ```\n   * <br />\n   */\n  (props?: StyleProps<Variants>): Directive<CSSRules>\n\n  /**\n   * CSS Selector associated with the current component.\n   *\n   * ```js\n   * const button = style({\n   *   base: {\n   *     color: \"DarkSlateGray\"\n   *   }\n   * })\n   *\n   * const article = style({\n   *   base: {\n   *     [button]: { boxShadow: \"0 0 0 5px\" }\n   *   }\n   * })\n   * ```\n   */\n  toString(): string\n\n  /**\n   * CSS Class associated with the current component.\n   *\n   * ```js\n   * const button = style({\n   *   base: {\n   *     color: \"DarkSlateGray\"\n   *   }\n   * })\n   *\n   * <div className={button.className} />\n   * ```\n   */\n  readonly className: string\n\n  /**\n   * CSS Selector associated with the current component.\n   *\n   * ```js\n   * const button = style({\n   *   base: {\n   *     color: \"DarkSlateGray\"\n   *   }\n   * })\n   *\n   * const Card = styled({\n   *   base: {\n   *     [Button.selector]: { boxShadow: \"0 0 0 5px\" }\n   *   }\n   * })\n   * ```\n   */\n  readonly selector: string\n}\n\nconst styled$ = (\n  rules: (undefined | string | CSSRules | Directive<CSSRules>)[],\n  context: Context,\n): CSSRules =>\n  rules.reduce((result: CSSRules, rule) => {\n    if (typeof rule == 'string') {\n      rule = apply(rule)\n    }\n\n    if (typeof rule == 'function') {\n      return merge(result, evalThunk(rule, context), context)\n    }\n\n    if (rule) {\n      return merge(result, rule as CSSRules, context)\n    }\n\n    return result\n  }, {})\n\nconst buildMediaRule = (key: string, value: undefined | StyleToken): CSSRules => ({\n  // Allow key to be an at-rule like @media\n  // Fallback to a screen value\n  [key[0] == '@' ? key : `@screen ${key}`]: typeof value == 'string' ? apply(value) : value,\n})\n\nconst createStyle = <Variants, BaseVariants>(\n  config: StyleConfig<Variants, BaseVariants> = {},\n  base?: Style<BaseVariants>,\n): Style<BaseVariants & Variants> & string => {\n  const { base: baseStyle, variants = {}, defaults, matches = [] } = config\n\n  const id = hash(JSON.stringify([base?.className, baseStyle, variants, defaults, matches]))\n  const className = (base ? base.className + ' ' : '') + id\n  const selector = (base || '') + '.' + id\n\n  return Object.defineProperties(\n    (allProps?: StyleProps<BaseVariants & Variants>): Directive<CSSRules> => {\n      const { tw, css, class: localClass, className: localClassName, ...props } = {\n        ...defaults,\n        ...allProps,\n      }\n\n      const rules: (undefined | string | CSSRules | Directive<CSSRules>)[] = [\n        base && base(props),\n        {\n          _:\n            className +\n            (localClassName ? ' ' + localClassName : '') +\n            (localClass ? ' ' + localClass : ''),\n        },\n        baseStyle,\n      ]\n\n      // Variants directives\n      Object.keys(variants).forEach((variantKey) => {\n        const variant = (variants as Record<string, Record<string, StyleToken>>)[variantKey]\n        const propsValue = (props as Record<string, unknown>)[variantKey]\n\n        // propsValues: string, number, boolean, object\n        if (propsValue === Object(propsValue)) {\n          Object.keys(propsValue as Record<string, unknown>).forEach((key) => {\n            const value = variant[(propsValue as Record<string, string>)[key]]\n\n            // key: breakpoint like sm, or it is a at-rule like @media or @screen\n            rules.push(key == 'initial' ? value : buildMediaRule(key, value))\n          })\n        } else {\n          rules.push(variant[propsValue as string])\n        }\n      })\n\n      matches.forEach((matcher) => {\n        const ruleIndex = rules.push(matcher.use) - 1\n\n        if (\n          !Object.keys(matcher).every((variantKey) => {\n            const propsValue = (props as Record<string, unknown>)[variantKey]\n            const compoundValue = String((matcher as Record<string, string>)[variantKey])\n\n            if (propsValue === Object(propsValue)) {\n              Object.keys(propsValue as Record<string, unknown>).forEach((key) => {\n                if (\n                  key != 'initial' &&\n                  compoundValue == String((propsValue as Record<string, unknown>)[key])\n                ) {\n                  // key: breakpoint like sm, or it is a at-rule like @media or @screen\n                  rules.push(buildMediaRule(key, rules[ruleIndex]))\n                }\n              })\n\n              return true\n            }\n\n            return variantKey == 'use' || compoundValue == String(propsValue)\n          })\n        ) {\n          rules.length = ruleIndex\n        }\n      })\n\n      rules.push(apply(tw), css)\n\n      return directive(styled$, rules)\n    },\n    {\n      toString: {\n        value: (): string => selector,\n      },\n      className: {\n        value: className,\n      },\n      selector: {\n        value: selector,\n      },\n    },\n  )\n}\n\nexport const style = (<Variants, BaseVariants>(\n  base: Style<BaseVariants> | StyleConfig<Variants>,\n  config?: StyleConfig<Variants, BaseVariants>,\n): Style<BaseVariants & Variants> & string =>\n  (typeof base == 'function' ? createStyle(config, base) : createStyle(base)) as Style<\n    BaseVariants & Variants\n  > &\n    string) as StyleFunction\n", "import type {\n  Context,\n  Hasher,\n  Falsy,\n  MaybeThunk,\n  CSSRules,\n  ThemeScreen,\n  ThemeScreenValue,\n  CSSRuleValue,\n} from '../types'\n\ninterface Includes {\n  (value: string, search: string): boolean\n  <T>(value: readonly T[], search: T): boolean\n}\n\nexport const includes: Includes = (value: string | readonly unknown[], search: unknown) =>\n  // eslint-disable-next-line no-implicit-coercion\n  !!~(value as string).indexOf(search as string)\n\nexport const join = (parts: readonly string[], separator = '-'): string => parts.join(separator)\n\nexport const joinTruthy = (parts: readonly (string | Falsy)[], separator?: string): string =>\n  join(parts.filter(Boolean) as string[], separator)\n\nexport const tail = <T extends string | readonly unknown[]>(array: T, startIndex = 1): T =>\n  array.slice(startIndex) as T\n\nexport const identity = <T>(value: T): T => value\n\nexport const noop = (): void => {\n  /* no-op */\n}\n\nexport const capitalize = <T extends string>(value: T): Capitalize<T> =>\n  (value[0].toUpperCase() + tail(value)) as Capitalize<T>\n\nexport const hyphenate = (value: string): string => value.replace(/[A-Z]/g, '-$&').toLowerCase()\n\nexport const evalThunk = <T>(value: MaybeThunk<T>, context: Context): T => {\n  while (typeof value == 'function') {\n    value = (value as (context: Context) => T)(context)\n  }\n\n  return value\n}\n\nexport const ensureMaxSize = <K, V>(map: Map<K, V>, max: number): void => {\n  // Ensure the cache does not grow unlimited\n  if (map.size > max) {\n    map.delete(map.keys().next().value)\n  }\n}\n\n// string, number or Array => a property with a value\nexport const isCSSProperty = (key: string, value: CSSRuleValue): boolean =>\n  !includes('@:&', key[0]) && (includes('rg', (typeof value)[5]) || Array.isArray(value))\n\nexport const merge = (target: CSSRules, source: CSSRules, context: Context): CSSRules =>\n  source\n    ? Object.keys(source).reduce((target, key) => {\n        const value = evalThunk(source[key], context)\n\n        if (isCSSProperty(key, value)) {\n          // hyphenate target key only if key is property like (\\w-)\n          target[hyphenate(key)] = value\n        } else {\n          // Keep all @font-face, @import, @global, @apply as is\n          target[key] =\n            key[0] == '@' && includes('figa', key[1])\n              ? ((target[key] || []) as CSSRules[]).concat(value as CSSRules)\n              : merge((target[key] || {}) as CSSRules, value as CSSRules, context)\n        }\n\n        return target\n      }, target)\n    : target\n\nexport const escape =\n  (typeof CSS !== 'undefined' && CSS.escape) ||\n  // Simplified: escaping only special characters\n  // Needed for NodeJS and Edge <79 (https://caniuse.com/mdn-api_css_escape)\n  ((className: string): string =>\n    className\n      // Simplifed escape testing only for chars that we know happen to be in tailwind directives\n      .replace(/[!\"'`*+.,;:\\\\/<=>?@#$%&^|~()[\\]{}]/g, '\\\\$&')\n      // If the character is the first character and is in the range [0-9] (2xl, ...)\n      // https://drafts.csswg.org/cssom/#escape-a-character-as-code-point\n      .replace(/^\\d/, '\\\\3$& '))\n\nexport const buildMediaQuery = (screen: ThemeScreen): string => {\n  if (!Array.isArray(screen)) {\n    screen = [screen as ThemeScreenValue]\n  }\n\n  return (\n    '@media ' +\n    join(\n      (screen as ThemeScreenValue[]).map((screen) => {\n        if (typeof screen == 'string') {\n          screen = { min: screen }\n        }\n\n        return (\n          (screen as { raw?: string }).raw ||\n          join(\n            Object.keys(screen).map(\n              (feature) => `(${feature}-width:${(screen as Record<string, string>)[feature]})`,\n            ),\n            ' and ',\n          )\n        )\n      }),\n      ',',\n    )\n  )\n}\n\n// Based on https://stackoverflow.com/a/52171480\nexport const cyrb32: Hasher = (value: string): string => {\n  // eslint-disable-next-line no-var\n  for (var h = 9, index = value.length; index--; ) {\n    h = Math.imul(h ^ value.charCodeAt(index), 0x5f356495)\n  }\n\n  return 'tw-' + ((h ^ (h >>> 9)) >>> 0).toString(36)\n}\n\n/**\n * Find the array index of where to add an element to keep it sorted.\n *\n * @returns The insertion index\n */\nexport const sortedInsertionIndex = (array: readonly number[], element: number): number => {\n  // Find position by binary search\n  // eslint-disable-next-line no-var\n  for (var low = 0, high = array.length; low < high; ) {\n    const pivot = (high + low) >> 1\n\n    // Less-Then-Equal to add new equal element after all existing equal elements (stable sort)\n    if (array[pivot] <= element) {\n      low = pivot + 1\n    } else {\n      high = pivot\n    }\n  }\n\n  return high\n}\n"],
  "mappings": "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",
  "names": ["includes", "hyphenate", "evalThunk", "isCSSProperty", "merge", "escape", "tw", "css"]
}
